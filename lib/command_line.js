// Generated by IcedCoffeeScript 1.6.3-b
(function() {
  var argv, auto_outfile, cleanse, collect_user_input, constants, exit_err, file_to_buffer, fs, go, iced, path, prompt, run, triplesec, __iced_k, __iced_k_noop, _optimist,
    __slice = [].slice;

  iced = {
    Deferrals: (function() {
      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) {
          return this.continuation(this.ret);
        }
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  constants = require('./constants');

  path = require('path');

  prompt = require('prompt');

  fs = require('fs');

  triplesec = require('triplesec');

  _optimist = require('optimist').string('o').alias('o', 'output').describe('o', 'output file').string('p').alias('p', 'passphrase').describe('p', 'passphrase as a parameter (not interactive)').options('m', {
    alias: 'message',
    describe: 'plaintext or ciphertext as a parameter, not a source file'
  }).string('m').boolean('k').alias('k', 'keep').describe('k', 'do not delete original file when outputting to file').boolean('s').alias('s', 'stdout').describe('s', 'stdout instead of file output').usage('Usage: $0 <lock|unlock> [filename] [options]');

  argv = _optimist.argv;


  /*
  
    O P T I O N S
  
      action:   string; (mandatory) "lock" or "unlock"
      filename: string; either this or message expected
      message:  string; either this or filename expected
      stdout:   bool;   if this then output to stdout    
      output:   string; filename; determined automatically if stdout not set and filename passed
  
    I M A G I N E D   E X A M P L E S
  
    3s lock
  
      3s lock foo.txt                                   # creates foo.txt.3s, deletes original
      3s lock foo.txt --output bar.3s                   # creates bar.3s, still deletes original
      3s lock foo.txt --keep                            # doesn't delete original
      3s lock foo.txt --keep --output bar.3s            # creates bar.3s, keeps original
      3s lock foo.txt --stdout                          # outputs foo.txt encrypted, keeps original
      3s lock foo.txt --passphrase 'eat a bag'          # doesn't ask for password
      3s lock --message 'hi there'                      # no file manipulation at all
      3s lock --output bar.3s --message 'hi there'
    
    3s unlock
  
      3s unlock foo.txt.3s                   # creates foo.txt, deletes original
      3s unlock foo.txt.3s --output bar.txt 
      etc.
  */

  exit_err = function(txt, no_show_help) {
    if (txt) {
      process.stdout.write("Error: " + txt + "\n");
    }
    if (!no_show_help) {
      _optimist.showHelp();
    }
    return process.exit(1);
  };

  file_to_buffer = function(opts, cb) {
    var buffer_enc, data, err, fname, m, read_enc, stats, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    fname = opts.filename;
    if (opts.action === "lock") {
      read_enc = "binary";
      buffer_enc = "binary";
    } else {
      read_enc = "utf8";
      buffer_enc = "base64";
    }
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/command_line.iced",
        funcname: "file_to_buffer"
      });
      fs.stat(fname, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return stats = arguments[1];
          };
        })(),
        lineno: 76
      }));
      __iced_deferrals._fulfill();
    })(function() {
      if (err) {
        exit_err("failed to find file " + fname, true);
      } else if (stats.size > (m = constants.max_srcfile_bytes)) {
        exit_err("source file too large (" + stats.size + "); max=" + m);
      } else if (stats.isDirectory()) {
        exit_err("source file is a directory");
      }
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/command_line.iced",
          funcname: "file_to_buffer"
        });
        fs.readFile(fname, {
          encoding: read_enc
        }, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return data = arguments[1];
            };
          })(),
          lineno: 83
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (err) {
          exit_err("failed to read file " + fname + " (" + err + ")");
        }
        opts.input_buffer = new Buffer(data, buffer_enc);
        return cb();
      });
    });
  };

  go = function(opts, cb) {
    var buff, err, fn, out, write_enc, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    fn = opts.action === "lock" ? triplesec.encrypt : triplesec.decrypt;
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/command_line.iced",
        funcname: "go"
      });
      fn({
        data: opts.input_buffer,
        key: opts.passphrase_buffer,
        progress_hook: function(o) {}
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return buff = arguments[1];
          };
        })(),
        lineno: 98
      }));
      __iced_deferrals._fulfill();
    })(function() {
      if (err && opts.action === "unlock") {
        return __iced_k(exit_err("check passphrase or input.", true));
      } else {
        (function(__iced_k) {
          if (err) {
            return __iced_k(exit_err("an unknown error occurred. Exiting.", true));
          } else {
            if (opts.action === 'lock') {
              write_enc = 'utf8';
              out = buff.toString('base64');
            } else {
              write_enc = 'utf8';
              out = buff;
            }
            if (opts.stdout) {
              process.stdout.write(out);
            }
            (function(__iced_k) {
              if (opts.output) {
                (function(__iced_k) {
                  __iced_deferrals = new iced.Deferrals(__iced_k, {
                    parent: ___iced_passed_deferral,
                    filename: "src/command_line.iced",
                    funcname: "go"
                  });
                  fs.writeFile(opts.output, out, {
                    encoding: write_enc
                  }, __iced_deferrals.defer({
                    assign_fn: (function() {
                      return function() {
                        return err = arguments[0];
                      };
                    })(),
                    lineno: 113
                  }));
                  __iced_deferrals._fulfill();
                })(function() {
                  (function(__iced_k) {
                    if (typeof err !== "undefined" && err !== null) {
                      return __iced_k(exit_err("could not write " + opts.output + ".", true));
                    } else {
                      (function(__iced_k) {
                        if ((!opts.keep) && (opts.filename != null)) {
                          (function(__iced_k) {
                            __iced_deferrals = new iced.Deferrals(__iced_k, {
                              parent: ___iced_passed_deferral,
                              filename: "src/command_line.iced",
                              funcname: "go"
                            });
                            fs.unlink(opts.filename, __iced_deferrals.defer({
                              assign_fn: (function() {
                                return function() {
                                  return err = arguments[0];
                                };
                              })(),
                              lineno: 117
                            }));
                            __iced_deferrals._fulfill();
                          })(function() {
                            return __iced_k(typeof err !== "undefined" && err !== null ? exit_err("failed to delete " + opts.filename + ".", true) : void 0);
                          });
                        } else {
                          return __iced_k();
                        }
                      })(__iced_k);
                    }
                  })(__iced_k);
                });
              } else {
                return __iced_k();
              }
            })(function() {
              return __iced_k(cb());
            });
          }
        })(__iced_k);
      }
    });
  };

  collect_user_input = function(opts, cb) {
    var err, x, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    prompt.message = "";
    prompt.delimiter = "";
    prompt.start();
    (function(__iced_k) {
      var _results, _while;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!!opts.passphrase) {
          return _break();
        } else {
          (function(__iced_k) {
            if (opts.action === "lock") {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/command_line.iced",
                  funcname: "collect_user_input"
                });
                prompt.get({
                  properties: {
                    p1: {
                      hidden: true,
                      description: "   Enter a passphrase: ",
                      type: "string",
                      pattern: /^.+$/
                    },
                    p2: {
                      hidden: true,
                      description: "Verify the passphrase: ",
                      type: "string",
                      pattern: /^.+$/
                    }
                  }
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      err = arguments[0];
                      return x = arguments[1];
                    };
                  })(),
                  lineno: 142
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/command_line.iced",
                  funcname: "collect_user_input"
                });
                prompt.get({
                  properties: {
                    p1: {
                      hidden: true,
                      description: "   Enter your passphrase: ",
                      type: "string",
                      pattern: /^.+$/
                    }
                  }
                }, __iced_deferrals.defer({
                  assign_fn: (function() {
                    return function() {
                      err = arguments[0];
                      return x = arguments[1];
                    };
                  })(),
                  lineno: 151
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            }
          })(function() {
            return _next(err ? exit_err("user requested exit...", true) : (opts.action === "lock") && (x.p1 !== x.p2) ? console.log("passwords didn't match") : !x.p1.length ? console.log("password empty") : opts.passphrase = x.p1);
          });
        }
      };
      _while(__iced_k);
    })(function() {
      return cb();
    });
  };

  auto_outfile = function(opts, cb) {
    if (opts.action === "lock") {
      opts.output = opts.filename + ".3s";
    } else {
      if (path.extname(opts.filename) === ".3s") {
        opts.output = opts.filename.slice(0, -3);
      } else {
        exit_err("expected -o, -s, or filename ending with .3s", true);
      }
    }
    return cb();
  };

  cleanse = function(opts) {
    if (opts.passphrase != null) {
      delete opts.passphrase;
    }
    if (opts.message != null) {
      return delete opts.message;
    }
  };

  run = exports.run = function() {
    var args, enc, exists, opts, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    opts = {};
    args = argv._;
    if (args.length < 1) {
      exit_err();
    }
    opts.action = args[0];
    if (args.length >= 2) {
      opts.filename = args[1];
    }
    if (argv.stdout != null) {
      opts.stdout = argv.stdout;
    }
    if ((typeof argv.output) === 'string') {
      opts.output = argv.output;
    }
    if ((typeof argv.message) === 'string') {
      opts.message = argv.message;
    }
    if ((typeof argv.passphrase) === 'string') {
      opts.passphrase = argv.passphrase;
    }
    if (argv.keep != null) {
      opts.keep = argv.keep;
    }
    if (!(opts.filename || opts.message)) {
      exit_err("expecting either a filename or a message");
    }
    if (opts.filename && opts.message) {
      exit_err("not expecting both a filename (" + opts.filename + ") and a message");
    }
    (function(__iced_k) {
      if (opts.filename) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/command_line.iced",
            funcname: "run"
          });
          file_to_buffer(opts, __iced_deferrals.defer({
            lineno: 199
          }));
          __iced_deferrals._fulfill();
        })(function() {
          (function(__iced_k) {
            if ((!opts.stdout) && (!opts.output)) {
              (function(__iced_k) {
                __iced_deferrals = new iced.Deferrals(__iced_k, {
                  parent: ___iced_passed_deferral,
                  filename: "src/command_line.iced",
                  funcname: "run"
                });
                auto_outfile(opts, __iced_deferrals.defer({
                  lineno: 201
                }));
                __iced_deferrals._fulfill();
              })(__iced_k);
            } else {
              return __iced_k();
            }
          })(__iced_k);
        });
      } else {
        enc = opts.action === 'unlock' ? 'base64' : 'binary';
        opts.input_buffer = new Buffer(opts.message, enc);
        return __iced_k(!opts.output ? opts.stdout = true : void 0);
      }
    })(function() {
      (function(__iced_k) {
        if (opts.output != null) {
          if (opts.filename && (path.resolve(opts.filename) === path.resolve(opts.output))) {
            exit_err("3s does not support outputting to input file", true);
          }
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/command_line.iced",
              funcname: "run"
            });
            fs.exists(opts.output, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  return exists = arguments[0];
                };
              })(),
              lineno: 210
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return __iced_k(exists ? exit_err("output file " + opts.output + " exists.") : void 0);
          });
        } else {
          return __iced_k();
        }
      })(function() {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/command_line.iced",
            funcname: "run"
          });
          collect_user_input(opts, __iced_deferrals.defer({
            lineno: 213
          }));
          __iced_deferrals._fulfill();
        })(function() {
          opts.passphrase_buffer = new Buffer(opts.passphrase);
          cleanse(opts);
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/command_line.iced",
              funcname: "run"
            });
            go(opts, __iced_deferrals.defer({
              lineno: 216
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return process.exit(0);
          });
        });
      });
    });
  };

  if (!module.parent) {
    run();
  }

}).call(this);
