// Generated by IcedCoffeeScript 1.6.3-d
(function() {
  var argv, cleanse, collect_user_input, constants, exit_err, file_to_buffer, fs, go, iced, path, prompt, run, triplesec, __iced_k, __iced_k_noop, _optimist,
    __slice = [].slice;

  iced = {
    Deferrals: (function() {
      function _Class(_arg) {
        this.continuation = _arg;
        this.count = 1;
        this.ret = null;
      }

      _Class.prototype._fulfill = function() {
        if (!--this.count) {
          return this.continuation(this.ret);
        }
      };

      _Class.prototype.defer = function(defer_params) {
        var _this = this;
        ++this.count;
        return function() {
          var inner_params, _ref;
          inner_params = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
          if (defer_params != null) {
            if ((_ref = defer_params.assign_fn) != null) {
              _ref.apply(null, inner_params);
            }
          }
          return _this._fulfill();
        };
      };

      return _Class;

    })(),
    findDeferral: function() {
      return null;
    },
    trampoline: function(_fn) {
      return _fn();
    }
  };
  __iced_k = __iced_k_noop = function() {};

  constants = require('./constants');

  path = require('path');

  prompt = require('prompt');

  fs = require('fs');

  triplesec = require('triplesec');

  _optimist = require('optimist').options('o', {
    alias: 'output',
    describe: 'output file'
  }).options('p', {
    alias: 'passphrase',
    describe: 'passphrase as a parameter (not interactive)'
  }).options('m', {
    alias: 'message',
    describe: 'plaintext or ciphertext as a parameter, not a source file'
  }).boolean('k').alias('k', 'keep-original').describe('k', 'do not delete original file when outputting to file').boolean('s').alias('s', 'stdout').describe('s', 'stdout instead of file output').usage('Usage: $0 <lock|unlock> [filename] [options]');

  argv = _optimist.argv;


  /*
  
    O P T I O N S
  
      action:   string; (mandatory) "lock" or "unlock"
      filename: string; either this or message expected
      message:  string; either this or filename expected
      stdout:   bool;   if this then output to stdout    
      output:   string; filename; determined automatically if stdout not set and filename passed
  
    I M A G I N E D   E X A M P L E S
  
    3s lock
  
      3s lock foo.txt                                   # creates foo.txt.enc, deletes original
      3s lock foo.txt --output bar.enc                  # creates bar.enc, still deletes original
      3s lock foo.txt --keep-original                   # doesn't delete original
      3s lock foo.txt --keep-original --output bar.enc  # creates bar.enc, keeps original
      3s lock foo.txt --stdout                          # outputs foo.txt encrypted, keeps original
      3s lock foo.txt --passphrase 'eat a bag'          # doesn't ask for password
      3s lock --message 'hi there'                      # no file manipulation at all
      3s lock --output bar.enc --message 'hi there'
    
    3s unlock
  
      3s unlock foo.txt.enc                   # creates foo.txt, deletes original
      3s unlock foo.txt.enc --output bar.txt 
      etc.
  */

  exit_err = function(txt, no_show_help) {
    if (txt) {
      console.log(txt);
    }
    if (!no_show_help) {
      _optimist.showHelp();
    }
    return process.exit(1);
  };

  file_to_buffer = function(fname, cb) {
    var data, err, m, stats, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/command_line.iced",
        funcname: "file_to_buffer"
      });
      fs.stat(fname, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return stats = arguments[1];
          };
        })(),
        lineno: 66
      }));
      __iced_deferrals._fulfill();
    })(function() {
      if (err) {
        exit_err("failed to stat file " + fname + " (" + (path.normalize(fname)) + ")");
      } else if (stats.size > (m = constants.max_srcfile_bytes)) {
        exit_err("source file too large (" + stats.size + "); max=" + m);
      } else if (stats.isDirectory()) {
        exit_err("source file is a directory");
      }
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/command_line.iced",
          funcname: "file_to_buffer"
        });
        fs.readFile(fname, __iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              err = arguments[0];
              return data = arguments[1];
            };
          })(),
          lineno: 73
        }));
        __iced_deferrals._fulfill();
      })(function() {
        if (err) {
          exit_err("failed to read file " + fname + " (" + err + ")");
        }
        return cb(data);
      });
    });
  };

  go = function(opts, cb) {
    var buff, enc, err, fn, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    fn = opts.action === "lock" ? triplesec.encrypt : triplesec.decrypt;
    (function(__iced_k) {
      __iced_deferrals = new iced.Deferrals(__iced_k, {
        parent: ___iced_passed_deferral,
        filename: "src/command_line.iced",
        funcname: "go"
      });
      fn({
        data: opts.input_buffer,
        key: opts.passphrase_buffer,
        progress_hook: function(o) {}
      }, __iced_deferrals.defer({
        assign_fn: (function() {
          return function() {
            err = arguments[0];
            return buff = arguments[1];
          };
        })(),
        lineno: 86
      }));
      __iced_deferrals._fulfill();
    })(function() {
      if (err && opts.action === "unlock") {
        return exit_err("Error! Check passphrase.", true);
      } else if (err) {
        return exit_err("An unknown error occurred. Exiting.", true);
      } else {
        enc = opts.action === 'lock' ? 'base64' : 'binary';
        if (opts.stdout) {
          console.log(buff.toString(enc));
        }
        return cb();
      }
    });
  };

  collect_user_input = function(opts, cb) {
    var err, x, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    prompt.message = "";
    prompt.delimiter = "";
    prompt.start();
    (function(__iced_k) {
      var _results, _while;
      _results = [];
      _while = function(__iced_k) {
        var _break, _continue, _next;
        _break = function() {
          return __iced_k(_results);
        };
        _continue = function() {
          return iced.trampoline(function() {
            return _while(__iced_k);
          });
        };
        _next = function(__iced_next_arg) {
          _results.push(__iced_next_arg);
          return _continue();
        };
        if (!!opts.passphrase) {
          return _break();
        } else {
          (function(__iced_k) {
            __iced_deferrals = new iced.Deferrals(__iced_k, {
              parent: ___iced_passed_deferral,
              filename: "src/command_line.iced",
              funcname: "collect_user_input"
            });
            prompt.get({
              properties: {
                p1: {
                  hidden: true,
                  description: "   Enter a passphrase: ",
                  type: "string",
                  pattern: /^.+$/
                },
                p2: {
                  hidden: true,
                  description: "Verify the passphrase: ",
                  type: "string",
                  pattern: /^.+$/
                }
              }
            }, __iced_deferrals.defer({
              assign_fn: (function() {
                return function() {
                  err = arguments[0];
                  return x = arguments[1];
                };
              })(),
              lineno: 116
            }));
            __iced_deferrals._fulfill();
          })(function() {
            return _next(err ? exit_err("\nexiting...", true) : x.p1 !== x.p2 ? console.log("passwords didn't match") : !x.p1.length ? console.log("password empty") : opts.passphrase = x.p1);
          });
        }
      };
      _while(__iced_k);
    })(function() {
      return cb();
    });
  };

  cleanse = function(opts) {
    if (opts.passphrase != null) {
      delete opts.passphrase;
    }
    if (opts.message != null) {
      return delete opts.message;
    }
  };

  run = exports.run = function() {
    var args, enc, opts, ___iced_passed_deferral, __iced_deferrals, __iced_k,
      _this = this;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    opts = {};
    args = argv._;
    if (args.length < 1) {
      exit_err();
    }
    opts.action = args[0];
    if (args.length >= 2) {
      opts.filename = args[1];
    }
    if (argv.message != null) {
      opts.message = argv.message;
    }
    if (argv.stdout != null) {
      opts.stdout = argv.stdout;
    }
    if (argv.passphrase != null) {
      opts.passphrase = argv.passphrase;
    }
    if (!(opts.filename || opts.message)) {
      exit_err("Expecting either a filename or a message");
    }
    if (opts.filename && opts.message) {
      exit_err("Not expecting both a filename (" + opts.filename + ") and a message");
    }
    (function(__iced_k) {
      if (opts.filename) {
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/command_line.iced",
            funcname: "run"
          });
          file_to_buffer(opts.filename, __iced_deferrals.defer({
            assign_fn: (function(__slot_1) {
              return function() {
                return __slot_1.input_buffer = arguments[0];
              };
            })(opts),
            lineno: 150
          }));
          __iced_deferrals._fulfill();
        })(__iced_k);
      } else {
        enc = opts.action === 'unlock' ? 'base64' : 'binary';
        opts.input_buffer = new Buffer(opts.message, enc);
        return __iced_k(!opts.output ? opts.stdout = true : void 0);
      }
    })(function() {
      (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "src/command_line.iced",
          funcname: "run"
        });
        collect_user_input(opts, __iced_deferrals.defer({
          lineno: 156
        }));
        __iced_deferrals._fulfill();
      })(function() {
        opts.passphrase_buffer = new Buffer(opts.passphrase);
        cleanse(opts);
        (function(__iced_k) {
          __iced_deferrals = new iced.Deferrals(__iced_k, {
            parent: ___iced_passed_deferral,
            filename: "src/command_line.iced",
            funcname: "run"
          });
          go(opts, __iced_deferrals.defer({
            lineno: 159
          }));
          __iced_deferrals._fulfill();
        })(function() {
          return process.exit(0);
        });
      });
    });
  };

  if (!module.parent) {
    run();
  }

}).call(this);
